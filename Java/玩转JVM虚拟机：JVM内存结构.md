# 玩转JVM虚拟机：JVM内存结构

## 一、JVM内存结构

![1](https://note.youdao.com/yws/res/33353/39EF376E88774ECDA1DA1606A1FE30E1)

### 1 程序计数器  

程序计数器（Program Counter Register），也有称作为PC寄存器。在汇编语言中，程序计数器是指CPU中的寄存器，它保存的是程序当前执行的指令的地址，当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。

虽然JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示执行哪条指令的。

由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。

在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。

由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。

### 2 Java栈

Java栈也称作虚拟机栈（Java Virtual Machine Stack），也就是我们常常所说的栈，跟C语言的数据段中的栈类似。事实上，Java栈是Java方法执行的内存模型。

Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(ReturnAddress)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。讲到这里，大家就应该会明白为什么 在 使用 递归方法的时候容易导致栈内存溢出的现象了，以及为什么栈区的空间不用程序员去管理了，这部分空间的分配和释放都是由系统自动实施的。

- 局部变量表，顾名思义，想必不用解释大家应该明白它的作用了吧。就是用来存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。
- 操作数栈，想必学过数据结构中的栈的朋友想必对表达式求值问题不会陌生，栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的。
- 指向运行时常量池的引用，因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。
- 方法返回地址，当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。 由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。

### 3 本地方法栈

本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在 HotSopt 虚拟机中直接就把本地方法栈和Java栈合二为一。

### 4 堆

Java中的堆是用来存储对象本身的以及数组，程序员基本不用去关心空间释放的问题，Java的垃圾回收机制会自动进行处理。因此这部分空间也是Java垃圾收集器管理的主要区域。另外，堆是被所有线程共享的，在JVM中只有一个堆。

### 5 方法区

方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。

在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。

在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。

## 二、JVM参数配置

用法：java-Xmx3550m -Xms3550m -Xmn2g -Xss128k

- Xss：每个线程的stack大小（栈）
- Xmx：JAVA HEAP的最大值、默认为物理内存的1/4
- Xms：JAVA HEAP的初始值，server端最好Xms与Xmx一样
- Xmn：JAVA HEAP young区的大小
- XX:MetaspaceSize：class metadata的初始空间配额，以bytes为单位，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整
- XX:MaxMetaspaceSize：可以为class metadata分配的最大空间。默认是没有限制的。

*注意：java8去掉了-XX:PermSize和-XX:MaxPermSize，新增了-XX:MetaspaceSize和-XX:MaxMetaspaceSize*

通过设置JVM参数后，我们可以使用jmap -heap pid命令来查看设置的性况，

![2](https://note.youdao.com/yws/res/33392/8B8686E732DF47029572AB884C0483CB)

- MaxHeapFreeRatio: GC后如果发现空闲堆内存占到整个预估堆内存的N%(百分比)，则收缩堆内存的预估最大值, 预估堆内存是堆大小动态调控的重要选项之一. 堆内存预估最大值一定小于或等于固定最大值(-Xmx指定的数值). 前者会根据使用情况动态调大或缩小, 以提高GC回收的效率
- MinHeapFreeRatio: GC后如果发现空闲堆内存占到整个预估堆内存的N%(百分比), 则放大堆内存的预估最大值
- MaxHeapSize: 即-Xmx, 堆内存大小的上限
- NewSize: 新生代预估堆内存占用的默认值
- MaxNewSize: 新生代占整个堆内存的最大值
- OldSize: 老年代的默认大小
- 老年代对比新生代的空间大小, 比如2代表老年代空间是新生代的两倍大小
- SurvivorRatio: Eden/Survivor的值。8表示Survivor:Eden=1:8,因为survivor区有2个, 所以Eden的占比为8/10
- MetaspaceSize: 分配给类元数据空间的初始大小
- CompressedClassSpaceSize: 类指针压缩空间大小, 默认为1G，在64位平台上指针压缩默认是打开的
- G1HeapRegionSize: G1区块的大小, 取值为1M至32M. 其取值是要根据最小Heap大小划分出2048个区块

补充：  
1. 使用-XX:+UseCompressedOops压缩对象指针
    - oops指的是普通对象指针(ordinary object pointers)。
    - Java堆中对象指针会被压缩成32位。
2. 使用-XX:+UseCompressedClassPointers选项来压缩类指针
    - 对象中指向类元数据的指针会被压缩成32位
    - 类指针压缩空间会有一个基地址
3. 元空间和类指针压缩空间的区别
    - 类指针压缩空间只包含类的元数据，比如InstanceKlass,ArrayKlass
    - 仅当打开了UseCompressedClassPointers选项才生效
    - 为了提高性能，Java中的虚方法表也存放到这里
    - 而元空间包含类的其它比较大的元数据，比如方法，字节码，常量池等。

接下来我们再使用jstat -gcutil pid来看一下内存的使用情况，如下图：
![3](https://note.youdao.com/yws/res/33424/E7D2BA1CF23D4EA98E03057B0760A982)

- S0:Survivor 0区的空间使用率.
- S1: Survivor 1区的空间使用率.
- E: Eden区的空间使用率.
- O: 老年代的空间使用率.
- M: 元数据的空间使用率.
- CCS: 类指针压缩空间使用率.
- YGC: 新生代GC次数.
- YGCT: 新生代GC总时长.
- FGC: Full GC次数.
- FGCT: Full GC总时长.
- GCT: 总共的GC时长.

三、常用查看内存的指令

- jinfo:可以输出并修改运行时的java 进程的信息。
-  jps:与unix上的ps类似，用来显示本地的java进程，可以查看本地运行着几个java程序，并显示他们的进程号。
-  jstat:一个极强的监视VM内存工具。可以用来监视VM内存内的各种堆和非堆的大小及其内存使用量。

```
jstat -class pid //显示加载class的数量，及所占空间等信息。
jstat -compiler pid //显示VM实时编译的数量等信息。
jstat -gc pid //可以显示gc的信息，查看gc的次数，及时间。
jstat -gcnew pid //new对象的信息。
jstat -gcnewcapacity pid //new对象的信息及其占用量。
jstat -gcold pid: old对象的信息。
jstat -gcoldcapacity pid //old对象的信息及其占用量。
jstat -gcpermcapacity pid //perm对象的信息及其占用量。
jstat -util pid:统计gc信息统计。
jstat -printcompilation pid //当前VM执行的信息。
jstat -gcutil pid 1000 10  //1000ms统计一次gc情况统计10次；
```

- Jstack:查看jvm线程运行状态，是否有死锁现象等等信息。
- jmap:打印出某个java进程内存内的所有对象的情况，如：产生那些对象，及其数量。  

```
jmap -dump:format=b,file=heap.bin<pid> //file：保存路径及文件名,pid：进程编号
jmap -histo:live  pid| less //堆中活动的对象以及大小
jmap -heap pid //查看堆的使用状况信息
```

- jconsole:一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM。

最后推荐一款查看jmap dump 的内存对象工具 MemoryAnalyzer网址：http://www.eclipse.org/mat/    可以查看dump时对象数量，内存占用，线程情况等。

推荐一起学习《分布式服务架构：原理、设计与实战》一书，它是一本不可多得的理论与实践相结合的架构秘籍，是作者多年工作经验积累的结晶。
