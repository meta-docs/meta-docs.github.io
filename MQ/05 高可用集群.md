# 高可用集群

RabbitMQ是用erlang开发的，集群非常方便，因为erlang天生就是一门分布式语言，但其本身并不支持负载均衡。Rabbit模式大概分为以下三种：单一模式、普通模式、镜像模式。

- 普通模式：默认的集群模式。  
对于Queue来说，消息实体只存在于其中一个节点，A、B两个节点仅有相同的元数据，即队列结构。当消息进入A节点的Queue中后，consumer从B节点拉取时，RabbitMQ会临时在A、B间进行消息传输，把A中的消息实体取出并经过B发送给consumer。
所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理Queue。否则无论consumer连A或B，出口总在A，会产生瓶颈。该模式存在一个问题就是当A节点故障后，B节点无法取到A节点中还未消费的消息实体。如果做了消息持久化，那么得等A节点恢复，然后才可被消费；如果没有持久化的话，然后就没有然后了……
- 镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案。  
该模式解决了上述问题，其实质和普通模式不同之处在于，消息实体会主动在镜像节点间同步，而不是在consumer取数据时临时拉取。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用（后面会详细介绍这种模式，目前我们搭建的环境属于该模式）。

### 1、集群中的基本概念
RabbitMQ的集群节点包括内存节点、磁盘节点。顾名思义内存节点就是将所有数据放在内存，磁盘节点将数据放在磁盘。不过，如前文所述，如果在投递消息时，打开了消息的持久化，那即使是内存节点，数据还是安全的放在磁盘。

一个RabbitMQ集群中可以共享user、vhost、queue、exchange等，所有的数据和状态都是必须在所有节点上复制的，一个例外是那些当前只属于创建它的节点的消息队列，尽管它们可见且可被所有节点读取。RabbitMQ节点可以动态地加入到集群中，一个节点它可以加入到集群中，也可以从集群环集群进行一个基本的负载均衡。

集群中有两种节点：
- 内存节点：只保存状态到内存（一个例外的情况是：持久的queue的持久内容将被保存到disk）
- 磁盘节点：保存状态到内存和磁盘。

内存节点虽然不写入磁盘，但是它执行比磁盘节点要好。集群中，只需要一个磁盘节点来保存状态 就足够了
如果集群中只有内存节点，那么不能停止它们，否则所有的状态，消息等都会丢失。

思路：
那么具体如何实现RabbitMQ高可用，我们先搭建一个普通集群模式，在这个模式基础上再配置镜像模式实现高可用，Rabbit集群前增加一个反向代理，生产者、消费者通过反向代理访问RabbitMQ集群。

架构图如下：

![image](https://raw.githubusercontent.com/ifcoder/note/master/image/rabbitmq/RabbitMQ高可用集群.jpg)

上述图里是3个RabbitMQ运行在同一主机上，分别用不同的服务端口。当然我们的生产实际里，多个RabbitMQ肯定是运行在不同的物理服务器上，否则就失去了高可用的意义。